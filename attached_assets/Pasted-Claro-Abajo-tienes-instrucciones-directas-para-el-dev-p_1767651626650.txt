Claro. Abajo tienes instrucciones directas para el dev para implementar Ahrefs API v3 en el
mÃ³dulo Keyword Gap & Visibility, con foco fuerte en control de costos, menos llamadas, y
salidas â€œAI-readyâ€.
âœ… Instrucciones para Dev â€” Implementar Ahrefs API v3
(Keyword Gap) con Control de Costos
ğŸ¯ Objetivo del mÃ³dulo
Encontrar keywords donde competidores rankean y la marca NO, priorizadas por:
volumen
KD
posiciÃ³n del competidor
(opcional) CPC / intenciÃ³n
Y entregar:
Top oportunidades
valor estimado
resumen por competidor
output estructurado JSON para anÃ¡lisis AI / reporte
1) Arquitectura recomendada (Low-cost)
âœ… Principio: NO usar endpoints â€œcarosâ€ repetidamente
En Ahrefs, lo mÃ¡s costoso no es solo la llamada: es llamar muchas veces sin cache, o traer
data que no necesitas.
ğŸ“Œ Por eso:
ğŸ”¥ Solo usar 1 endpoint base:
âœ… site-explorer/organic-keywords
Ese endpoint te da:
keyword
posiciÃ³n
volumen
KD
URL
trÃ¡fico estimado
1/6
Con esto se puede construir el â€œgapâ€ en cÃ³digo, sin depender del Content Gap endpoint (que
en algunos casos es mÃ¡s limitado o menos controlable).
2) Flujo completo recomendado
STEP A â€” Extraer keywords orgÃ¡nicas por dominio
Endpoint:
GET /v3/site-explorer/organic-keywords
ParÃ¡metros sugeridos (para reducir costo)
target={domain}
mode=domain
country=us (o el que defina el config)
limit=2000 (mÃ¡ximo controlado)
where=position<=20 âœ… (clave para bajar ruido)
order_by=traffic_desc o volume_desc
ğŸ“Œ IMPORTANTE: limitar a top 20 reduce millones de keywords basura.
STEP B â€” Construir â€œsetsâ€ y hacer gap en cÃ³digo
1. client_kw = set(keywords donde client rankea pos<=100 o <=50)
2. Para cada competidor:
comp_kw = set(keywords donde comp rankea pos<=20)
3. Gap:
gap_kw = comp_kw - client_kw
âœ… Esto replica Content Gap pero mÃ¡s barato y controlable.
STEP C â€” Enriquecer mÃ©tricas (sin nuevas llamadas)
Cuando traes organic keywords del competidor, ya tienes:
volume
KD
position
url
traffic
âœ… Entonces al calcular gap, ya tienes lo necesario sin hits adicionales.
STEP D â€” Filtrado (para evitar output basura)
Aplicar reglas de negocio:
2/6
Filtros mÃ­nimos:
volume >= 500
KD <= 40 (configurable)
pos_competitor <= 20
excluir keywords â€œbrand competitorâ€ si aplica
Guardrails:
excluded_terms solo generan warn , nunca block
out_of_fence â†’ warn
in-scope â†’ pass
STEP E â€” Scoring de oportunidad (simple y barato)
Un score bÃ¡sico (sin ML) que da 80% del valor:
Donde:
kd_norm = KD / 100
position_weight = 1.0 si pos<=5, 0.7 si <=10, 0.5 si <=20
3) Estrategia de costos (CRÃTICA)
âœ… Regla #1: Cachear agresivamente
TTL recomendado:
7 dÃ­as (weekly cache)
si quieren â€œfastâ€: TTL 3 dÃ­as
Los gaps no cambian diariamente.
Cache key:
keyword_gap:{client}:{country}:{competitor_list_hash}:{filters_hash}
âœ… Regla #2: No llamar Ahrefs para cada keyword
ğŸš« NO llamar keyword explorer por keyword
âœ… Solo 1 batch por dominio
âœ… Regla #3: Limitar competidores en MVP
mÃ¡ximo 3 competidores en alpha
mÃ¡ximo 5 en producciÃ³n
python
score = (log(volume) * (1 - kd_norm) * position_weight)
3/6
no mÃ¡s de 5 nunca
âœ… Regla #4: Mantener â€œlimitâ€ controlado por dominio
RecomendaciÃ³n:
traer top 2000 por dominio (pos<=20)
normalmente se reduce a 200â€“600 keywords Ãºtiles
âœ… Regla #5: â€œIncremental refreshâ€
Si guardas data de competidor:
no re-fetch si ya fue actualizado esta semana
refresh only delta (si se puede)
4) Outputs necesarios (para report + AI)
Output 1 â€” Summary
Output 2 â€” Table Top Opportunities
Campos mÃ­nimos:
keyword
volume
KD
competitor_position
competitor_url
score
status(pass/warn)
reason
Output 3 â€” Breakdown por competidor
json
{
"client": "oofos.com",
"competitors": ["hoka.com","crocs.com"],
"total_gap_keywords": 412,
"passed": 260,
"warn": 152,
"top_opportunity_value_usd": 183400
}
json
4/6
5) ImplementaciÃ³n sugerida (estructura de cÃ³digo)
Servicios:
ahrefsClient.ts
keywordGapService.ts
cacheService.ts
Funciones clave:
fetchOrganicKeywords(domain, country, positionLimit, limit)
buildGapKeywords(clientKeywords, competitorKeywords[])
applyGuardrails(keyword, config) -> pass|warn
scoreKeyword(keywordData) -> float
saveSnapshotToDB(snapshot)
6) â€œLite Modeâ€ para reducir costo aÃºn mÃ¡s (recomendado)
Si quieren ahorrar todavÃ­a mÃ¡s:
traer solo top 500 keywords por competidor
usar order_by=traffic_desc
solo keywords con volume >= 500
Esto produce un output â€œejecutivoâ€, no exhaustivo.
7) Checklist (para dev)
âœ… Implementar organic-keywords endpoint
âœ… Implementar cache TTL semanal
âœ… Implementar limit y filtros antes de guardar
âœ… Implementar scoring simple
âœ… Output JSON estÃ¡ndar (summary + table + breakdown)
âœ… Guardrails solo warn / pass
âœ… UI: mostrar â€œWarnings require reviewâ€, no bloquear
8) RecomendaciÃ³n final (para Susan / producto)
En OOFOS el problema del output malo se ve claro:
[
{"competitor":"hoka.com","gap_keywords":220,"top_value":91000},
{"competitor":"crocs.com","gap_keywords":192,"top_value":92000}
]
5/6
El sistema estÃ¡ dejando pasar muchas keywords â€œHoka brand queriesâ€ como
â€œopportunityâ€
Eso es porque el Fence estÃ¡ demasiado amplio o no hay filtro de intenciÃ³n
Con Ahrefs + scoring + filtro non-brand eso se arregla
âœ… PrÃ³ximo paso si quieres
Puedo entregarte tambiÃ©n:
1. PseudocÃ³digo completo en TypeScript
2. Esquema de DB para guardar snapshots y evitar re-hits
3. Lista de parÃ¡metros exactos para Ahrefs v3 segÃºn el plan (lite / full)
Solo dime cuÃ¡l necesitas primero.
6/6