Aqu√≠ tienes instrucciones claras para el programador (tipo ‚Äúimplementation plan‚Äù) para corregir el Keyword Gap Lite y que deje de generar output basura, sin romper el principio de ‚Äúno bloquear‚Äù y optimizando para Ahrefs.

‚úÖ Objetivo del fix

Transformar el m√≥dulo de:

‚ÄúLista de keywords donde el competidor rankea y nosotros no‚Äù

a:

‚ÄúLista priorizada de oportunidades capturables para la categor√≠a del cliente, separando ruido (brand terms, talles, SKUs) en out_of_play y evitando que contamine el Top.‚Äù

1) Cambios de modelo de datos (Schema)
1.1 Agregar campos nuevos en KeywordResult

Agregar:

type KeywordStatus = "pass" | "review" | "out_of_play";

type IntentType = 
  | "category_capture"
  | "problem_solution"
  | "product_generic"
  | "brand_capture"
  | "variant_or_size"
  | "other";

interface KeywordResult {
  keyword: string;
  normalizedKeyword: string;

  // existing
  searchVolume: number;
  cpc?: number;
  kd?: number;
  competitorPosition?: number;

  // NEW
  status: KeywordStatus;         // pass/review/out_of_play (no "block")
  intentType: IntentType;        // clasificaci√≥n simple
  capabilityScore: number;       // 0..1
  opportunityScore: number;      // number usado para sort
  reason: string;                // explicaci√≥n humana
  flags: string[];               // e.g. ["competitor_brand", "size_variant"]
}


Nota: ‚Äúout_of_play‚Äù NO bloquea. Solo evita que contamine el ranking.

2) Cambiar la l√≥gica de guardrails (UCR) a 3 niveles
2.1 Separar ‚Äúexclusiones‚Äù en 2 listas

En configuraci√≥n UCR agregar:

negative_scope_review: string[];      // manda a review
negative_scope_out_of_play: string[]; // manda a out_of_play
competitor_brand_terms: string[];     // marcas y modelos (hoka, bondi, clifton)
variant_terms: string[];             // size, wide, mens, womens, colores, etc.

Regla:

match competitor_brand_terms ‚Üí out_of_play

match variant_terms (talles/modelos/colores + marca) ‚Üí out_of_play

match negative_scope_out_of_play ‚Üí out_of_play

match fence ‚Äúd√©bil‚Äù ‚Üí review

match fence ‚Äúfuerte‚Äù ‚Üí pass

3) Implementar Intent Classification (sin IA, barato)

Crear funci√≥n deterministic:

function classifyIntent(keyword: string, config: Configuration): IntentType

Reglas sugeridas (regex / tokens)

Si contiene marca competidora: brand_capture

Si contiene size|wide|4e|mens|women|7.5|8.5|39|40|41|42|black|white ‚Üí variant_or_size

Si contiene best|for plantar fasciitis|arch support|pain relief|recovery ‚Üí problem_solution

Si contiene sandals|slides|recovery sandals|recovery slides ‚Üí category_capture

Si contiene t√©rminos gen√©ricos de producto (shoes si OOFOS no vende shoes) ‚Üí other

No hace falta perfecto: solo suficiente para ordenar bien.

4) Capability Score (la pieza clave)

Crear:

function computeCapabilityScore(keyword: string, config: Configuration): number

Heur√≠stica r√°pida (0..1)

Ejemplo para OOFOS (sandals/slides recovery):

+0.6 si keyword contiene recovery

+0.3 si keyword contiene sandals|slides

-0.7 si keyword contiene running shoes|hiking boots|marathon training

-0.6 si keyword contiene marca competidora

clamp 0..1

Luego:

capability < 0.3 ‚Üí status = out_of_play

0.3‚Äì0.6 ‚Üí review

0.6 ‚Üí puede ser pass si tambi√©n est√° in-fence

5) Opportunity Score (nuevo sorting)

Cambiar sorting de volumen a score compuesto.

intentWeight = {
  category_capture: 1.0,
  problem_solution: 1.0,
  product_generic: 0.7,
  brand_capture: 0.2,
  variant_or_size: 0.0,
  other: 0.1
}

opportunityScore =
  (searchVolume || 0) *
  (cpc || 1) *
  intentWeight[intentType] *
  capabilityScore

Sorting nuevo

status: pass ‚Üí review ‚Üí out_of_play

opportunityScore desc

searchVolume desc

6) UI / Output: c√≥mo se muestra para que ‚Äúno parezca malo‚Äù

En el output separa secciones:

‚úÖ Top Opportunities (pass)

‚ö†Ô∏è Needs Review (review)

üí§ Out of Play (hidden by default)

Y agregar un summary arriba:

% pass

% review

% out_of_play

‚ÄúX keywords removidas del top por ser brand/variants‚Äù

7) Migrar DataForSEO ‚Üí Ahrefs (Keyword Gap)
7.1 Endpoint recomendado

Usar Ahrefs content_gap en modo domain con m√∫ltiples competidores (1 call si es posible).

Inputs:

target = brand domain

competitors = list

mode = domain

positions 1‚Äì20

min volume (ej. 500)

(opcional) min cpc > 0

Guardar:

keyword

volume

cpc

kd

competitor positions

7.2 Caching

Cache por:

brand + competitors + min_volume + positions
TTL:

semanal (keyword gaps no cambian diario)

8) QA Tests (para evitar regresi√≥n)

Crear tests con keywords known-bad:

Must go out_of_play

‚Äúall black hoka shoes‚Äù

‚Äú39 birkenstock size‚Äù

‚Äú20 week marathon plan‚Äù

‚Äúhoka bondi 8 slip resistant‚Äù

Must go pass

‚Äúrecovery sandals‚Äù

‚Äúsandals for plantar fasciitis‚Äù

‚Äúbest recovery slides‚Äù

‚Äúarch support sandals‚Äù

Assertions:

Nunca aparecen en Top Opportunities si status != pass

opportunityScore > 0 solo para pass/review

9) Minimal deliverable (lo que deben implementar primero)

Si quieres versi√≥n MVP sin sobre-engineering:

‚úÖ Implementar primero:

competitor brand list ‚Üí out_of_play

size/variant regex ‚Üí out_of_play

opportunityScore + sorting

UI separando pass/review/out_of_play

Eso solo ya arregla 80% del problema.

Copiar/pegar para Jira (tarea resumida)

Task: Improve Keyword Gap Lite relevance
Goal: Prevent competitor-brand and variant queries from dominating results; prioritize capturable category demand.
Deliverables:

Add status: pass/review/out_of_play (no blocking)

Add intentType, capabilityScore, opportunityScore

Add competitor_brand_terms + variant_terms filters ‚Üí out_of_play

Replace sorting with opportunityScore

UI shows 3 sections; out_of_play collapsed

Replace DataForSEO with Ahrefs content_gap + weekly caching