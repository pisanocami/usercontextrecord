SÃ­: **es totalmente posible** que con â€œel mismo contextoâ€ te salga **Peak/Low distinto**, pero en tu caso hay **dos causas separadas**:

## 1) VariaciÃ³n real del proveedor (normalizaciÃ³n de Trends)

Cuando consultas DataForSEO/Google Trends, los valores estÃ¡n **normalizados y pueden recalcularse**. PequeÃ±os cambios en la serie semanal pueden hacer que el â€œmes ganadorâ€ cambie (pico/valle).
Eso explica variaciones *pequeÃ±as*.

**Pero** pasar de **Peak Apr â†’ Peak Oct** con el mismo dÃ­a/contexto suele indicar otra cosaâ€¦

---

## 2) Bug de producto: estÃ¡s promediando mÃºltiples categorÃ­as en un solo â€œresultado genÃ©ricoâ€

Tu propio hallazgo es el clave:

> â€œNo estÃ¡ contemplando que el anÃ¡lisis puede ser por varias categorÃ­as y estÃ¡ dando un resultado genÃ©ricoâ€

Si tu UCR/inputs incluyen 5 keywords de **categorÃ­as distintas** (p.ej. *Recovery footwear*, *Athletic sandals*, *Orthopedic sandals*, *Comfort shoes*, *Active lifestyle*), cada una puede tener estacionalidad diferente.

Si el sistema:

* junta todo,
* calcula un promedio,
* y luego extrae peak/low del agregado,

entonces el â€œpeakâ€ puede cambiar *muchÃ­simo* segÃºn:

* cuÃ¡l keyword tuvo mÃ¡s ruido esa corrida,
* cÃ³mo se normalizÃ³ esa consulta,
* cÃ³mo se agruparon/ordenaron los tÃ©rminos.

ğŸ‘‰ Resultado: **un peak â€œgenÃ©ricoâ€ que no representa ninguna categorÃ­a bien**, y ademÃ¡s es inestable.

---

# Instrucciones concretas para el dev (lo que hay que hacer)

## A) Cambiar el output: de â€œ1 resultadoâ€ â†’ â€œresultado por categorÃ­aâ€

En vez de:

```ts
MarketDemandResult { peakMonth, lowMonth, ... } // Ãºnico
```

hacer:

```ts
MarketDemandResult {
  overall?: { ... }        // opcional, solo si lo quieren
  byCategory: Array<{
    categoryName: string
    queries: string[]
    peakMonth: string
    lowMonth: string
    stabilityScore: number
    timingRecommendation: { launchBy: string, rationale: string }
    series: Array<{ date: string, value: number }>
    heatmap: Record<string, number> // month -> intensity
    trace: RunTrace
  }>
}
```

## B) Ejecutar Trends por categorÃ­a (no mezclado)

Si hoy haces 1 llamada con 5 tÃ©rminos mezclados, hay que pasar a:

* por cada categorÃ­a:

  * armar su set de queries
  * llamar DataForSEO Trends
  * calcular peak/low y estabilidad **por esa serie**
* luego renderizar cards por categorÃ­a

## C) UX: tarjetas por categorÃ­a + un â€œoverallâ€ opcional

En UI:

* â€œRecovery footwear â€” Peak Apr/Mayâ€
* â€œAthletic sandals â€” Peak Julâ€
* â€œOrthopedic sandals â€” Peak Octâ€
  y debajo, si quieren:
* â€œOverall (weighted) â€” informational onlyâ€

## D) Para consistencia: cache por (ucr_hash + category + timeframe)

Esto evita que un rerun inmediato cambie el peak por ruido.

Cache key ejemplo:

```
marketDemand:{ucrHash}:{categoryName}:{country}:{timeRange}:{granularity}
ttl: 24h (o 7d)
```

---

# QuÃ© decirle al equipo (explicaciÃ³n simple)

â€œHoy el mÃ³dulo estÃ¡ agregando mÃºltiples categorÃ­as en un solo promedio. Eso genera un pico â€˜genÃ©ricoâ€™ que puede cambiar entre corridas y no representa bien ninguna categorÃ­a. La soluciÃ³n es segmentar por categorÃ­a y devolver un peak/low por cada una, con cache por configuraciÃ³n.â€

---

Si querÃ©s, te dejo tambiÃ©n:

* el **pseudo-cÃ³digo exacto** de `runMarketDemandByCategory()`
* y el **contrato** actualizado en `module.contract.ts` para Market Demand (output spec + required UCR sections).
